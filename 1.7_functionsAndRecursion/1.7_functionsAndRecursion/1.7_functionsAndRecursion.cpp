#include <iostream>

using namespace std;




int  main() {
	int a, b, c, d;
	cin >> a >> b >> c >> d;
}

/*
6. Дано число N. Определите, сколькими способами можно расставить на доске N×N N ферзей, не бьющих друг друга.
  Формат входных данных
	Задано единственное число N. (N ≤ 10)
  Формат выходных данных
	Выведите ответ на задачу.
  Подсказка
	Напишите рекурсивную функцию, которая пытается поставить ферзя в очередной столбец. Если на эту клетку ставить
	ферзя нельзя (он бьет предыдущих), то такой вариант даже не стоит рассматривать.
	Когда вы успешно поставили ферзя в последний столбец - увеличивайте счетчик.
	Sample: 8 => 92
*/

/*
1. Даны пять действительных чисел: x, y, xc, yc, r. Проверьте, принадлежит ли точка (x, y) кругу с центром (xc, yc) и радиусом r.
	Если точка принадлежит кругу, выведите слово YES, иначе выведите слово NO.
	Решение должно содержать функцию IsPointInCircle(x, y, xc, yc, r), возвращающую True, если точка принадлежит кругу и False, если не принадлежит.
	Основная программа должна считать координаты точки, вызвать функцию IsPointInCircle и в зависимости от возвращенного значения вывести на экран необходимое сообщение.
	Функция IsPointInCircle не должна содержать инструкцию if.
bool IsPointInCircle(double	x, double y, double xc, double yc, double r) {
	return sqrt((x - xc) * (x - xc) + (y - yc) * (y - yc)) <= r;}
int main() {
	double x, y, xc, yc, r;
	cin >> x >> y >> xc >> yc >> r;
	IsPointInCircle(x, y, xc, yc, r) ? cout << "YES" : cout << "NO";

2. Проверьте, принадлежит ли точка данной закрашенной области:
	f(y)=-x, f(y) = 2(x-1), круг - r=2, xc=-1, yc=1
	
	bool IsPointInArea(double x, double y) {
	double a = x + y;
	double b = y - 2 * x - 2;
	double c = sqrt(pow(x + 1, 2) + pow(y - 1, 2));
	return a >= 0 && b >= 0 && c <= 2 || a <= 0 && b <= 0 && c >= 2;
	}
	int main() {
	double x, y;
	cin >> x >> y;
	IsPointInArea(x, y) ? cout << "ee" : cout << "no";

3. Дано действительное положительное число a и целоe число n.
	Вычислите a^n. Решение оформите в виде рекурсивной функции power(a, n).

	long double power(long double a, int n) {
	if (n == 0) { return 1; }
	else if (n > 0) { return a * power(a, --n); }
	else if (n < 0) { return (1 / a) * power(a, ++n); }
}
int main() {
	long double a;
	int n;
	cin >> a >> n;
	cout << power(a, n);
4. Возводить в степень можно гораздо быстрее, чем за n умножений! Для этого нужно воспользоваться следующими рекуррентными соотношениями:
	an = (a^2)^(n/2)  при четном n,
	an = a × a^(n−1) при нечетном n.
	Реализуйте алгоритм быстрого возведения в степень с помощью рекурсивной функции.
long double power(long double a, int n) {
	if (n == 0) return 1;
	if (n % 2 == 0) return power(a*a, n/2);
	else if (n % 2 != 0) return a * power(a, n-1);
}
int main() {
	long double a;
	int n;
	cin >> a >> n;
	cout << power(a, n);


*/
/*
5. В небоскребе n этажей. Известно, что если уронить стеклянный шарик с этажа номер p, и шарик разобьется, то если
	уронить шарик с этажа номер p+1, то он тоже разобьется. Также известно, что при броске с последнего этажа шарик всегда разбивается.	
	Вы хотите определить минимальный номер этажа, при падении с которого шарик разбивается. Для проведения экспериментов у вас есть два шарика.
	Вы можете разбить их все, но в результате вы должны абсолютно точно определить этот номер.
	Определите, какого числа бросков достаточно, чтобы заведомо решить эту задачу.
  Формат входных данных
	Программа получает на вход количество этажей в небоскребе.
  Формат выходных данных
	Требуется вывести наименьшее число бросков, при котором можно всегда решить задачу.
  Примечание
	Комментарий к первому примеру. Нужно бросить шарик со 2-го этажа. Если он разобьется, то бросим второй шарик с 1-го этажа, 
	а если не разобьется - то бросим шарик с 3-го этажа.
  Подсказки
	1. Как следует действовать, если шарик был бы только один?
	2. Пусть шариков два и мы бросили один шарик с этажа номер k. Как мы будем действовать в зависимости от того, разобьется ли шарик или нет?
	3. Пусть f(n) - это минимальное число бросков, за которое можно определить искомый этаж, если бы в небоскребе было n этажей.
	Выразите f(n) через значения f(a) для меньших значений a.

int SearchForIntervals(int last_floor) {
	int i = 0;
	while ((i * i + i) / 2 < (last_floor - 1)) i++;
	return i;
}
int main() {
	int last_floor, i = 0;
	cin >> last_floor;
	cout << SearchForIntervals(last_floor);
	return 0;
}
	
	разбор полётов - https://stepik.org/lesson/13027/step/15?discussion=3467056&thread=solutions&unit=4379
	
	
	*/


