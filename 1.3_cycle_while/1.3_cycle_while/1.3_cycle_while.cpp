#include <iostream>
using namespace std;

int main() {
	int n, pre = 0, now = 0, i = 0, i2=0, i1 = 0, inow = 0, imin = 0, k = 0 ;
	cin >> n;
	while (i < 2) {
		i++;
		pre = now;
		now = n;
		cin >> n;
	}
	while (n != 0) {
		if (now > pre and now > n) {
			k++;
			i2 = i1;
			i1 = i;
			inow = i1 - i2;
			if (k == 2) imin = inow;
			else if (k > 2 && imin > inow) imin = inow;
		}
		i++;
		pre = now;
		now = n;
		cin >> n;
	}
	cout << imin;
}

/* 
1 2 2 2 2 2 1 0
0
1 2 2 3 2 2 1 0
0
3 2 2 2 2 2 2 2 2 2 2 2 2 3 0
0
3 2 2 2 2 2 2 3 2 2 2 2 2 3 0
0
1 3 2 2 3 1 0
3
18 11 16 14 3 1 2 18 5 2 12 5 2 3 1 0
3
6 6 7 7 19 3 20 11 15 1 2 0
2
20 4 1 8 12 7 14 5 19 17 10 6 5 3 15 13 12 0
2
4 6 3 20 6 5 12 14 16 8 4 20 20 16 0
2
13 18 14 15 10 20 5 7 17 2 1 18 20 19 15 12 14 10 0
2
6 5 17 15 2 1 6 12 5 13 0
5
6 13 8 20 13 5 17 6 6 13 0
2
13 10 7 17 18 11 14 10 4 1 10 12 8 6 0
2
3 1 16 2 5 6 2 18 3 12 0
2
9 9 10 15 11 5 8 9 6 7 7 15 17 17 19 1 19 12 18 8 0
2*/







/* 1 2 1 1 2 1 2 1 0
1. По данному целому числу N распечатайте все квадраты натуральных чисел, не превосходящие N, в порядке возрастания.
	int n, i = 1;
    cin >> n;
    while (i * i <= n) {
        cout << i * i << " ";
        ++i;
	}
	50 -> 1 4 9 16 25 36 49

2. Дано целое число, не меньшее 2. Выведите его наименьший натуральный делитель, отличный от 1.
	int n, i = 2;
	cin >> n;
	while (n % i != 0) ++i;
	cout << i;
3. По данному числу N распечатайте все целые степени двойки, не превосходящие N, в порядке возрастания.
	int n, i = 1;
	cin >> n;
	while (i <= n) {
		cout << i << " ";
		i = i * 2;
	}
	50 -> 1 2 4 8 16 32
4. Дано натуральное число N. Выведите слово YES, если число N является точной степенью двойки, или слово NO в противном случае.
	a.
	int n, i = 1;
	cin >> n;
	while (i * 2 <= n) {
		i = i * 2;}
	cout << ((i == n) ? "yes" : "no");
	b. побитовое перемножение
	int n;
	std::cin >> n;
	if (n & n - 1)
		std::cout << "NO";
	else
		std::cout << "YES";
	с. 
	int n;
	cin >> n;
	while(n % 2 == 0) n /= 2;
	cout << ((n == 1) ? "YES" : "NO");
5. Программа получает на вход последовательность целых неотрицательных чисел, каждое число записано в отдельной строке. 
	Последовательность завершается числом 0, при считывании которого программа должна закончить свою работу и вывести
	количество членов последовательности (не считая завершающего числа 0).
	Числа, следующие за числом 0, считывать не нужно.
	a. 
	int n, i = 0;
	cin >> n;
	while (n != 0) {
		cin >> n;
		++i;
	}
	cout << i;
	b. с диким выебоном до колена
	int main() {
	int i = 0, a;
	while(std::cin >> a && a && ++i);
	std::cout << i;
6. Определите сумму всех элементов последовательности, завершающейся числом 0.
	a.
	int now, sum = 0;
	cin >> now;
	while (now != 0) {
		sum += now;
		cin >> now;
	}
	cout << sum;
	b. 	
	int n, i = 0;
	while (cin >> n && n && (i += n));
    cout << i; 
7. Последовательность состоит из натуральных чисел и завершается числом 0. 
	Определите значение наибольшего элемента последовательности.
	int now, max = 0;
	cin >> now;
	while (now != 0) {
		if (now > max) max = now;
		cin >> now;
	}
	cout << max;
8. Последовательность состоит из натуральных чисел и завершается числом 0. Определите, какое количество элементов 
	этой последовательности, равны ее наибольшему элементу.
	int now, max = 0, i = 0;
	cin >> now;
	while (now != 0) {
		if (now > max) {
			max = now;
			i = 1;
		}
		else if (now == max) ++i;
		cin >> now;
	}
	cout << i;
9. Последовательность состоит из натуральных чисел и завершается числом 0. Определите значение второго по величине элемента 
	в этой последовательности, то есть элемента, который будет наибольшим, если из последовательности удалить наибольший элемент.
	int now, max = 0, pre = 0;
	cin >> now;
	while (now != 0) {
		if (now >= max) {
			pre = max;
			max = now;
		}
		else if (pre < max and pre < now)
			pre = now;

		cin >> now;
	}
	cout << pre;
10. Последовательность Фибоначчи определяется так: F(0) = 0, F(1) = 1, …, F(n) = F(n−1) + F(n−2).
	По данному числу N определите N-е число Фибоначчи F(N).
	int f0 = 0, f1 = 1, fn = 0, n, i = 1;
	cin >> n;
	while (n > i) {
		fn = f0 + f1;
		f0 = f1;
		f1 = fn;
		++i;
	}
	cout << fn;
11. Последовательность Фибоначчи определяется так: F(0) = 0, F(1) = 1, …, F(n) = F(n−1) + F(n−2).
	Дано натуральное число A. Определите, каким по счету числом Фибоначчи оно является, то есть выведите такое число N,
	что F(N) = A. Если А не является числом Фибоначчи, выведите число -1.
	int f0 = 0, f1 = 1, fn = 0, n = 1, a;
	cin >> a;
	while (fn < a) {
		fn = f0 + f1;
		f0 = f1;
		f1 = fn;
		++n;
	}
	cout << ((fn == a) ? n : -1);
12. Дана последовательность натуральных чисел, завершающаяся числом 0. Определите, какое наибольшее число
	подряд идущих элементов этой последовательности равны друг другу. Если не нашлось ни одной пары, 
	тройки и т.д. элементов, равных друг другу, то программа должна вывести число 1.
	int now, pre = 0, i = 0, k = 0;
	cin >> now;
	while (now) {
		if (now != pre) {
			pre = now;
			i = 1;
		}
		else if (now = pre)
			++i;
		if (i > k) k = i;
		cin >> now;
	}
	cout << k;
13. Элемент последовательности называется локальным максимумом, если он строго больше предыдущего и последующего
	элемента последовательности. Первый и последний элемент последовательности не являются локальными максимумами.
	Дана последовательность натуральных чисел, завершающаяся числом 0.
	Определите количество строгих локальных максимумов в этой последовательности.
	int now, pre2 = 0, pre1 = 0, i = 0;
	cin >> now;
	while (now) {
		if (pre1 > pre2 and pre1 > now) ++i;
		pre2 = pre1;
		pre1 = now;
		cin >> now;
	}
	cout << i;

14. Определите наименьшее расстояние между двумя локальными максимумами последовательности натуральных чисел, завершающейся числом 0.
	Если в последовательности нет двух локальных максимумов, выведите число 0.
	Начальное и конечное значение при этом локальными максимумами не считаются.
	Расстоянием считается количество пробелов между элементами. В качестве примера смотрите первый тест.
  Формат входных данных
	Вводится последовательность целых чисел, оканчивающаяся числом 0 (само число 0 в последовательность не входит, а служит как признак ее окончания).
  Формат выходных данных
	Выведите ответ на задачу.

	int n, pre = 0, now = 0, i = 0, i2=0, i1 = 0, inow = 0, imin = 0, k = 0 ;
	cin >> n;
	while (i < 2) {
		i++;
		pre = now;
		now = n;
		cin >> n;
	}
	while (n != 0) {
		if (now > pre and now > n) {
			k++;
			i2 = i1;
			i1 = i;
			inow = i1 - i2;
			if (k == 2) imin = inow;
			else if (k > 2 && imin > inow) imin = inow;
		}
		i++;
		pre = now;
		now = n;
		cin >> n;
	}
	cout << imin;


*/
