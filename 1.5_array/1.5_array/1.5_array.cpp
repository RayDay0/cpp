#include <iostream>
#include <vector>

using namespace std;

int main() {
	int n, k;
	cin >> n >> k;
	vector <char> a(n);
	for (int i = 0; i < n; i++) a[i] = 'I'; // не понял почему не работает auto
	//обработка
	for (int i = 0; i < k; i++) {
		int l, r;
		cin >> l >> r;
		l--; r--;	//т.к. индекс начинается с нуля, то понижаем позиции кеглей
		for (int j = 0; j < n; j++)
			if (j >= l and j <= r) a[j] = '.';
	}
	//вывод
	for (auto now : a) cout << now;
}

/* сортировка выбором минимума
	int n;
	cin >> n;
	vector <int> a;
	//считывание
	for (int i = 0; i < n; i++) {
		int t;
		cin >> t;
		a.push_back(t);
	}
	//обработка
	for (int j = 0; j < n; j++) {
		int min = j;
		for (int i = j; i < n; i++) {
			if (a[i] < a[min]) {
				min = i;
			}
		}
		//обмен значений a[0] и a[min]
		int t;
		t = a[j];
		a[j] = a[min];
		a[min] = t;
	}
	//вывод
	for (auto now : a) {
		cout << now << " ";
	}

1. Дан массив целых чисел. Если в нем есть два соседних элемента одного знака, выведите эти числа. 
	Если соседних элементов одного знака нет - не выводите ничего. Если таких пар соседей несколько - выведите первую пару.
   Формат входных данных
	В первой строке вводится количество элементов в массиве. Во второй строке вводятся элементы массива. Все числа отличны от нуля. 
  Формат выходных данных
	Выведите ответ на задачу. Элементы выводятся в порядке неубывания.
____a.
	int n, i = 0;
	bool flag = false;
	cin >> n;
	vector <int> a(n);
	for (int i = 0; i < n && flag == false; i++) 
	{
		cin >> a[i];
		if (i > 0 && (a[i] * a[i - 1]) > 0) 
		{
			flag = true;
			cout << min(a[i], a[i - 1]) << " " << max(a[i], a[i - 1]);
		}
	}
____b.
	int n;
	cin >> n;
	vector <int> a;
	//считывание
	for (int i = 0; i < n; i++)
	{
		int t;
		cin >> t;
		a.push_back(t);
	}
	for (int i = 1; i < n; i++)
		if (a[i] > 0 and a[i - 1] > 0 or a[i] < 0 and a[i - 1] < 0)
		{
			a[i] > a[i - 1] ? cout << a[i - 1] << " " << a[i] :
				cout << a[i] << " " << a[i - 1];
			break;
		}
2. Выведите значение наименьшего из всех положительных элементов в массиве. Известно, что в массиве есть хотя бы один положительный элемент.
  Формат входных данных
	В первой строке вводится количество элементов в массиве. Во второй строке вводятся элементы массива.
	int n;
	cin >> n;
	vector <int> a;
	//считывание
	for (int i = 0; i < n; i++)
	{
		int t;
		cin >> t;
		if (t > 0)
		a.push_back(t);
	}
	//обработка
	int min = 0;
	for (int i = a.size() - 1; i >= 0; i--) {
		if (a[i] < a[min]) min = i;
	}
	//вывод
	cout << a[min];
3. Выведите значение наименьшего нечетного элемента списка, а если в списке нет нечетных элементов - выведите число 0.
  Формат входных данных
	В первой строке вводится количество элементов в массиве. Во второй строке вводятся элементы массива.
	int n;
	cin >> n;
	vector <int> a;
	//reading
	for (int i = 0; i < n; i++) {
		int temp;
		cin >> temp;
		if (temp % 2 != 0) {
			a.push_back(temp);
		}
	}
	//processing
	int min = 0;
	if (a.size() != 0) {
		for (int i = a.size() - 1; i >= 0; i--) {
			if (a[i] < a[min]) {
				min = i;
			}
		}
	}
	//print
	a.size() == 0 ? cout << 0 : cout << a[min];
4. Дан список, упорядоченный по неубыванию элементов в нем. Определите, сколько в нем различных элементов.
  Формат входных данных
	В первой строке вводится количество элементов в массиве. Во второй строке вводятся элементы массива.
____a. new
	int n;
	cin >> n;
	vector <int> a;
	//считывание
	for (int i = 0; i < n; i++)
	{
		int t;
		cin >> t;
		a.push_back(t);
	}
	//обработка
	int m = 1;
	for (int i = 1; i < n; i++) {
		if (a[i] > a[i - 1]) m++;
	}
	//вывод
	cout << m;
____b. old
	int n, j = 1, temp, min;
	cin >> n;
	cin >> temp;
	min = temp;
	for (int i = 1; i < n; i++) { 
		cin >> temp;
		if (min < temp) {
			min = temp;
			j++;
		}
	}
	cout << j;
5. Переставьте соседние элементы массива (A[0] c A[1], A[2] c A[3] и т.д.). Если элементов нечетное число, то последний элемент остается на своем месте.
  Формат входных данных
	В первой строке вводится количество элементов в массиве. Во второй строке вводятся элементы массива.
____a. new
	int n;
	cin >> n;
	vector <int> a;
	//считывание
	for (int i = 0; i < n; i++)
	{
		int t;
		cin >> t;
		a.push_back(t);
	}
	//обработка
	for (int i = 0; i < n / 2 * 2; i += 2) { // i < n / 2 * 2 - если вектор нечётный
		int temp = 0;
		temp = a[i];
		a[i] = a[i + 1];
		a[i + 1] = temp;
	}
	//вывод
	for (auto now : a) cout << now << " ";
____b. old
	int n;
	cin >> n;
	vector <int> a(n);
	for (int i = 0; i < n; i++) {
		int temp;
		cin >> a[i];
		if (i % 2 == 1) {
			temp = a[i - 1];
			a[i - 1] = a[i];
			a[i] = temp;
		}
	}
	for (auto now : a) {
		cout << now << " ";
	}

6. Циклически сдвиньте элементы списка вправо (A[0] переходит на место A[1],
	A[1] на место A[2], ..., последний элемент переходит на место A[0]).
____a. old
	int n;
	cin >> n;
	vector <int> a(n);
	for (int i = 0; i < n; i++) {
		if (i == n - 1)
		cin >> a[0];
		else if (i < n)
			cin >> a[i+1];
	}
	for (auto now : a)
		cout << now << " ";
____b. new
	int n;
	cin >> n;
	vector <int> a(n);
	//считывание
	for (int i = 0; i < n; i++) {
		cin >> a[i];
	}
	//обработка
	int a_temp = a[n - 1];
	for (int i = 0; i < n; i++) {
		int temp = a[i];
		a[i] = a_temp;
		a_temp = temp;
	}
	//вывод
	for (auto now : a) cout << now << " ";

7. Дан массив чисел. Посчитайте, сколько в нем пар элементов, равных друг другу. Считается,
	что любые два элемента, равные друг другу образуют одну пару, которую необходимо посчитать.
	int n, s = 0;
	cin >> n;
	vector <int> a;
	//считывание
	for (int i = 0; i < n; i++) {
		int temp;
		cin >> temp;
		a.push_back(temp);
	}
	//обработка
	for (int j = 0; j < n; j++) {
		int now = j;
		for (int i = j + 1; i < n; i++) {
			if (a[now] == a[i])
				s++;
		}
	}
	//вывод
	cout << s;
8. Известно, что на доске 8×8 можно расставить 8 ферзей так, чтобы они не били друг друга. 
	Вам дана расстановка 8 ферзей на доске, определите, есть ли среди них пара бьющих друг друга.
  Формат входных данных
	Программа получает на вход восемь пар чисел, каждое число от 1 до 8 - координаты 8 ферзей.
  Формат выходных данных
	Если ферзи не бьют друг друга, выведите слово NO, иначе выведите YES.
	int k = 0;
	vector <int> a(8), b(8);
	//считывание
	for (int i = 0; i < 8; i++) {
		cin >> a[i] >> b[i];
	}
	// обработка
	for (int i = 0; i < 8; i++) {
		for (int x = 0; x < 8; x++) {
			if ((a[i] == a[x] or b[i] == b[x] or
				(a[i] + b[i] == a[x] + b[x])) and i != x) {
				k++;
			}
		}
	}
	k == 0 ? cout << "NO" : cout << "YES";
*/
/*
9. N кеглей выставили в один ряд, занумеровав их слева направо числами от 1 до N. Затем по этому ряду бросили K шаров, при этом i-й шар сбил все кегли с номерами от li до ri включительно. Определите, какие кегли остались стоять на месте.
  Формат входных данных
	Программа получает на вход количество кеглей N и количество бросков K. Далее идет K пар чисел li, ri, при этом 1 ≤ li, ri ≤ N.
  Формат выходных данных
	Программа должна вывести последовательность из N символов, где j-й символ есть “I”, если j-я кегля осталась стоять, или “.”, если j-я кегля была сбита.
  Sample Input:
	10 3
	8 10
	2 5
	3 6
  Sample Output:

	I.....I...

	int n, k;
	cin >> n >> k;
	vector <char> a(n);
	for (int i = 0; i < n; i++) a[i] = 'I'; // не понял почему не работает auto
	//обработка
	for (int i = 0; i < k; i++) {
		int l, r;
		cin >> l >> r;
		l--; r--;	//т.к. индекс начинается с нуля, то понижаем позиции кеглей
		for (int j = 0; j < n; j++)
			if (j >= l and j <= r) a[j] = '.';
	}
	//вывод
	for (auto now : a) cout << now;

	
	
*/